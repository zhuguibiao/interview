# 事件循环

## 解释
  [事件循环官方解释](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue)：
  > 为了协调事件、用户交互、脚本、渲染、网络等，用户代理必须使用本节所述的事件循环。每个代理都有一个相关联的事件循环，这个事件循环对该代理来说是独一无二的。

  >窗口代理的事件循环被称为**窗口事件循环（ window event loop）**。
  >专用工作者代理、共享工作者代理或服务工作者代理的事件循环被称为**工作者事件循环（worker event loop）**。
  >而worklet代理的事件循环称为 **worklet事件循环（worklet event loop)**。

## 事件循环的描述
- 浏览器有一个**循环监听机制**，监听消息，如果有新的任务消息，就放入任务队列（**task**）。

- 一个事件循环有一个或多个任务队列。一个任务队列是一组的任务（注意不是完全的先入先出，而是看是否可执行的，取的时候是取队列第一个可以执行的）。

- 任务队列的是宏任务，每一个宏任务都有一个微任务队列。

- 在宏任务的执行过程中产生微任务会被添加到改列表中，等当前宏任务快执行结束之后，会执行微任务列表。
  
- 当然了微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任务和微任务有一些本质上的区别！

- 一个事件循环的task大致有这些类型

- 事件、拆分、回调、使用资源、对DOM操作的反应、步骤、一个源、一个文档、一个脚本评估环境设置对象集。

- 每个事件循环都有一个当前运行的任务，这个任务要么是任务，要么是null。最初，这是null。它用于处理重入性。

- 每个事件循环都有一个微任务队列，这是一个微任务队列，初始为空。微任务是一种通俗的方式，指的是通过队列一个微任务算法创建的任务。

- 每个事件循环都有一个执行微任务检查点的布尔值，初始为假。它用于防止重新调用执行一个微任务检查点算法

- 例如：一个用户代理可以有一个鼠标和按键事件的任务队列（用户交互任务源与之相关联），另一个任务队列与所有其他任务源相关联。然后，利用事件循环处理模型的初始步骤所赋予的自由度，它可以在四分之三的时间内优先考虑键盘和鼠标事件，而不是其他任务，从而保持界面的响应性，但又不会饿死其他任务队列。请注意，在这种设置中，处理模型仍然强制要求用户代理绝不会不按顺序处理任何一个任务源的事件。


## 事件循环的task的任务类型
  我们再来看看消息队列中的任务类型有哪些。这里面包含了很多内部消息类型，如 **输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器**等等。

  除此之外，消息队列中还包含了很多与页面相关的事件，如 J**avaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画**等。

  - **事件**
      在特定的EventTarget对象上调度事件对象，通常由专门的任务来完成。
      并非所有的事件都是使用任务队列来调度的；许多事件是在其他任务中调度的。

  - **解析**
      HTML解析器对一个或多个字节进行标记化，然后对产生的任何标记进行处理，这是一个典型的任务。

  - **回调**
      调用回调通常由专门的任务来完成。

  - **使用资源**
      当算法获取资源时，如果获取是以非阻塞的方式发生的，那么一旦资源的部分或全部可用，则由任务进行处理。
      
  - **对DOM操作的反应**
     一些元素有响应DOM操作的任务，例如当该元素被插入到文档中时，就会触发。

 正式来说，任务是一个结构，它具有以下功能:

  - **步骤**
   一系列步骤，规定任务要做的工作。

  - **一个源头**
    任务源之一，用于对相关任务进行分组和序列化。

  - **一个文档**
    与任务相关联的文档，对于不在窗口事件循环中的任务，则为空。

  - **脚本评估环境设置对象集**
    一组环境设置对象，用于在任务期间跟踪脚本评估。

    如果一个任务的文档为空或完全激活，则该任务是可运行的。

    根据其源字段，每个任务被定义为来自特定的任务源。对于每个事件循环，每个任务源必须与特定的任务队列相关联。

## 任务流程（处理模式）

一个事件循环只要存在，就必须不断地运行以下步骤。

1. 让taskQueue成为事件循环的任务队列之一，以实现定义的方式选择，约束条件是所选的任务队列必须至少包含一个可运行的任务。如果没有这样的任务队列，则跳到下面的微任务步骤。
   > 请记住，微型任务队列不是任务队列，所以不会在这一步中选择它。但是，在此步骤中可能会选择微任务任务源相关联的任务队列。在这种情况下，下一步中选择的任务原本是一个微任务，但它作为旋转事件循环的一部分被移动了。

2. 让 oldestTask 成为 taskQueue 中第一个可运行的任务，并将其从 taskQueue 中删除。

3. 将事件循环的当前运行任务设置为 oldestTask。

4. 让taskStartTime为当前的高解析时间。

5. 执行 oldestTask 的步骤。

6. 将事件循环的当前运行的任务设回null。

7. 微任务。执行一个微任务检查点

8. 让hasARenderingOpportunity为false。

9. 让now为当前的高分辨率时间。

10. 通过执行以下步骤来报告任务的持续时间。

    - 让顶层浏览上下文是一个空集。

    - 对于 oldestTask 的脚本评估环境设置对象集的每个环境设置对象设置，将设置的顶层浏览上下文追加到顶层浏览上下文中。

    - 报告长任务，传入taskStartTime、now（任务的结束时间）、顶层浏览上下文和oldestTask。


## 宏任务和微任务
1. 任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver

2. 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering

很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。

所以正确的一次 Event loop 顺序是这样的
执行同步代码，这属于宏任务
执行栈为空，查询是否有微任务需要执行
执行所有微任务
必要的话渲染 UI
然后开始下一轮 Event loop，执行宏任务中的异步代码
通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。