<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function myPromise(executor) {
        // 状态，初始化pendding
        // 成功为fulfilled，失败变为rejected
        this.state = "pending";
        // 成功的值
        this.value = undefined;
        // 失败的原因
        this.reason = undefined;

        let resolve = (value) => {
          // state改变,resolve调用就会失败
          if (this.state === "pending") {
            // resolve调用后，state转化为成功态
            this.state = "fulfilled";
            // 储存成功的值
            this.value = value;
          }
        };
        let reject = (reason) => {
          // state改变,reject调用就会失败
          if (this.state === "pending") {
            // reject调用后，state转化为失败态
            this.state = "rejected";
            // 储存失败的原因
            this.reason = reason;
          }
        };
        try {
          content(resolve, reject);
        } catch (err) {
          reject(err);
        }
      }

      myPromise.prototype.then = function (onFulfilled, onRejected) {
        // then 方法 有两个参数onFulfilled onRejected
        if (this.state === "fulfilled") {
          onFulfilled(this.value);
        }
        // 状态为rejected，执行onRejected，传入失败的原因
        if (this.state === "rejected") {
          onRejected(this.reason);
        }
      };

      // 返回结果为数组，有一个失败就直接reject 数组未调用的直接没了。
      myPromise.all = function (promises) {
        var results = [];
        var completedPromises = 0;
        return new Promise((resolve, reject) => {
          promises.forEach((promise, index) => {
            Promise.resolve(resolve)
              .then((value) => {
                results[index] = value;
                completedPromises += 1;
                if (completedPromises === promises.length) {
                  resolve(results);
                }
              })
              .catch((err) => {
                reject(err);
              });
          });
        });
      };

      // 如果reject 继续尝试，知道传入的次数还是失败，那么就失败，否者成功
      myPromise.retry = function (fn, num) {
        return new Promise(function (resolve, reject) {
          while (num > 0) {
            fn.then(res=>{

            }).catch(err=>{
              if(!num) reject(e)
            })
            try{
                  const res = await fn
                  resolve(res)
                  num = 0
            } catch(e){
                  if(!num) reject(e)
            }
            num--;
          }
        });
      };

      // 返回promise，不管失败还是成功都是resolve。
      myPromise.allSettled = function (promises) {
        if (promises instanceof Array) {
          let result = [];
          promises.forEach((i) => {
            ret.push(
              new Promise(function (resolve, reject) {
                i.then((v) => {
                  resolve({ state: "fulfilled", data: v });
                }).catch((e) => {
                  resolve({ state: "rejected", reason: e });
                });
              })
            );
          });
          return Promise.all(result);
        }
        return Promise.reject();
      };

      // 返回promise，race竞争的意思，就是看传入数组的是哪一个先出结果，最先返回的就是race的返回结果
      myPromise.race = function (promises){}
    </script>
  </body>
</html>
